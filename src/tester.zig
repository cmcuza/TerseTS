// Copyright 2024 TerseTS Contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Provides methods for testing TerseTS.

const std = @import("std");
const ArrayList = std.ArrayList;
const Random = std.Random;
const Allocator = std.mem.Allocator;
const Error = std.mem.Allocator.Error;
const math = std.math;
const time = std.time;
const testing = std.testing;
const debug = std.debug;

const tersets = @import("tersets.zig");
const Method = tersets.Method;

const shared = @import("utilities/shared_structs.zig");

/// `global_at_least` and `global_at_most` define the default minimum and maximum bounds for
/// generating random integer values in tests. These values are chosen to provide a reasonable
/// range for most scenarios, balancing test coverage and performance.
pub const global_at_least: usize = 10;
pub const global_at_most: usize = 50;

/// Probability used when replacing a value with a special float (NaN, +inf, -inf) in test generators.
/// This value is passed to `replaceNormalValues` and determines the likelihood that any
/// normal value will be replaced by one of the three special types. For example, with
/// `global_replace_probability = 0.05` and 100 values generated, each replacement type has an expected
/// count of ~5. The chance that at least one special value appears is ~0.9999 assuming three
/// independent trials per value. The value should be in the range [0.01, 1] to retain a ~0.99
/// probability of replacement.
pub const global_replace_probability: f32 = 0.05;

/// The maximum absolute value used for generating test data in bounded random value generators.
/// This value is chosen to be 1e15 because it is large enough to test the behavior of compression
/// algorithms with high-magnitude numbers, but still small enough to avoid floating-point overflows
/// and precision loss in typical f64 operations. All test data generated by functions such as
/// `generateDefaultBoundedValues`, `generateRandomSinusoidalFunction`, and `generateRandomLinearFunction`
/// will be clamped within [-max_test_value, max_test_value] to ensure numerical stability.
pub const max_test_value: f64 = 1.0e15;

/// Different data distributions used for testing.
pub const DataDistribution = enum {
    LinearFunctions,
    BoundedRandomValues,
    SinusoidalFunction,
    FiniteRandomValues,
    RandomValuesWithNansAndInfinities,
    LinearFunctionsWithNansAndInfinities,
    BoundedRandomValuesWithNansAndInfinities,
    SinusoidalFunctionWithNansAndInfinities,
};

/// Run a suite of experiments using different data generators to verify a compression `method`
/// works for a wide range of inputs. The `allocator` is used for memory management, and
/// `data_distributions` specifies which data distributions to test against the compression method.
/// The function generates a random error bound between [1.0e-4, 1.0) per data distribution
/// to guarantee that different error bounds are tested. The error bound is later used
/// to generate an absolute error bound based on the range of the distributed data.
pub fn testErrorBoundedCompressionMethod(
    allocator: Allocator,
    method: Method,
    data_distributions: []const DataDistribution,
) !void {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = Random.DefaultPrng.init(seed);
    const random = prng.random();

    for (data_distributions) |dist| {
        const error_bound: f32 = random.float(f32) + 1e-4; // Ensure a non-zero error bound.
        switch (dist) {
            .LinearFunctions => try testGeneratedCompression(
                allocator,
                generateRandomLinearFunctions,
                method,
                error_bound,
                "Linear Functions",
            ),
            .BoundedRandomValues => try testGeneratedCompression(
                allocator,
                generateDefaultBoundedValues,
                method,
                error_bound,
                "Bounded Values",
            ),
            .SinusoidalFunction => try testGeneratedCompression(
                allocator,
                generateRandomSinusoidalFunction,
                method,
                error_bound,
                "Sinusoidal Function",
            ),
            .FiniteRandomValues => try testGeneratedCompression(
                allocator,
                generateFiniteRandomValues,
                method,
                error_bound,
                "Finite Values",
            ),
            .RandomValuesWithNansAndInfinities => try testGeneratedCompression(
                allocator,
                generateRandomValuesWithNaNs,
                method,
                error_bound,
                "Random Values with NaNs and Infinities",
            ),
            .LinearFunctionsWithNansAndInfinities => try testGeneratedCompression(
                allocator,
                generateRandomLinearFunctionsWithNaNs,
                method,
                error_bound,
                "Linear Functions with NaNs and Infinities",
            ),
            .BoundedRandomValuesWithNansAndInfinities => try testGeneratedCompression(
                allocator,
                generateDefaultBoundedValuesWithNaNs,
                method,
                error_bound,
                "Bounded Random Values with NaNs and Infinities",
            ),
            .SinusoidalFunctionWithNansAndInfinities => try testGeneratedCompression(
                allocator,
                generateRandomSinusoidalFunctionWithNaNs,
                method,
                error_bound,
                "Sinusoidal Function with NaNs and Infinities",
            ),
        }
    }
}

/// Test that values generated by `uncompressedValuesGenerator` are within `error_bound` after they
/// have been compressed and decompressed using `method`. The libraries public interface is used to
/// make it simpler refactor the libraries internals. The input `error_bound` is used to computed
/// the an absolute error bound based on the range of the generated values.
pub fn testGeneratedCompression(
    allocator: Allocator,
    uncompressedValuesGenerator: fn (
        uncompressed_values: *ArrayList(f64),
        random: Random,
    ) Error!void,
    method: Method,
    error_bound: f32,
    data_distribution_name: []const u8,
) !void {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = Random.DefaultPrng.init(seed);
    const random = prng.random();

    var uncompressed_values = ArrayList(f64).init(allocator);
    defer uncompressed_values.deinit();
    try uncompressedValuesGenerator(&uncompressed_values, random);

    // Ensure that the error bound is a percentage of the range of the uncompressed values.
    // To avoid scanning for the minimum and maximum values, the first and last values are used
    // as a proxy for the range. This is a simplification, but it is sufficient for testing purposes.
    const ranged_error_bound: f32 = @floatCast(@abs(
        uncompressed_values.items[0] - uncompressed_values.items[uncompressed_values.items.len - 1],
    ) * error_bound);

    const compressed = try tersets.compress(
        uncompressed_values.items,
        allocator,
        method,
        ranged_error_bound,
    );
    defer compressed.deinit();

    const decompressed = try tersets.decompress(compressed.items, allocator);
    defer decompressed.deinit();

    if (uncompressed_values.items.len != decompressed.items.len) {
        try testing.expectFmt(
            "",
            "Seed: {}, expected_len {}, found_len {}",
            .{ seed, uncompressed_values.items.len, decompressed.items.len },
        );
        return;
    }

    for (uncompressed_values.items, decompressed.items, 0..) |raw_value, decompressed_value, i| {
        // Check if the decompressed value is within the error bound of the expected value.
        // Cast the difference between raw and decompressed values to f32 before comparing
        // to the `f32` error bound, to ignore insignificant differences below f32 precision.
        // This prevents false test failures due to `f64` rounding noise.
        if (@as(f32, @floatCast(@abs(raw_value - decompressed_value))) > ranged_error_bound) {
            try testing.expectFmt(
                "",
                "Seed: {}, index {}, raw value {}, compressed value {}, error bound {},\n error bound exceeded by {}, with data distribution: {s} \n previous raw value {}, next raw value {}\n",
                .{
                    seed,
                    i,
                    raw_value,
                    decompressed_value,
                    ranged_error_bound,
                    @abs(raw_value - decompressed_value) - ranged_error_bound,
                    data_distribution_name,
                    if (i - 1 >= 0) uncompressed_values.items[i - 1] else 0.0,
                    if (i + 1 < uncompressed_values.items.len) uncompressed_values.items[i + 1] else 0.0,
                },
            );
            return;
        }
    }
}

/// Test that values generated by `uncompressed_values_generator` are within `error_bound` according
/// to `within_error_bound` after they have been compressed and decompressed using `method`. The
/// libraries public interface is used to make it simpler refactor the libraries internals.
pub fn testGenerateCompressAndDecompress(
    allocator: Allocator,
    uncompressedValuesGenerator: fn (
        uncompressed_values: *ArrayList(f64),
        random: Random,
    ) Error!void,
    method: Method,
    error_bound: f32,
    withinErrorBound: fn (
        uncompressed_values: []const f64,
        decompressed_values: []const f64,
        error_bound: f32,
    ) bool,
) !void {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = Random.DefaultPrng.init(seed);
    const random = prng.random();

    var uncompressed_values = ArrayList(f64).init(allocator);
    try uncompressedValuesGenerator(&uncompressed_values, random);
    defer uncompressed_values.deinit();

    // subsequenceStack contains subsequences to run the test for to find shortest failing sequence.
    var subsequenceStack = ArrayList(usize).init(allocator);
    defer subsequenceStack.deinit();

    try subsequenceStack.append(0);
    try subsequenceStack.append(uncompressed_values.items.len);
    var shortestStart: usize = 0;
    var shortestEnd: usize = math.maxInt(usize);

    while (subsequenceStack.items.len != 0) {
        // subsequenceStack contains start and end as separate integers of usize.
        const end = subsequenceStack.pop().?;
        const start = subsequenceStack.pop().?;
        const uncompressed_values_subsequence = uncompressed_values.items[start..end];

        testCompressAndDecompress(
            allocator,
            uncompressed_values_subsequence,
            method,
            error_bound,
            withinErrorBound,
        ) catch {
            // To simplify debugging failed tests that use auto generated data, the tests are
            // retried with smaller subsequence to find the smallest subsequence that fails.
            if (start < end - 1) {
                const middle = (start + end) / 2;
                try subsequenceStack.append(start);
                try subsequenceStack.append(middle);
                try subsequenceStack.append(middle);
                try subsequenceStack.append(end);
            }

            if (end - start < shortestEnd - shortestStart) {
                shortestStart = start;
                shortestEnd = end;
            }

            // Subsequences cannot be shorter than one element.
            if (end - start == 1) {
                break;
            }
        };
    }

    // HACK: std.testing has no functionality including a message with an error, thus a string with
    // an informative message is compared to an empty string to ensure it will fail and be printed.
    if (shortestEnd != math.maxInt(usize)) {
        try testing.expectFmt(
            "",
            "Seed: {}, Values: {any}",
            .{ seed, uncompressed_values.items[shortestStart..shortestEnd] },
        );
    }
}

/// Test that `uncompressed_values` are within `error_bound` according to `within_error_bound` after
/// it has been compressed and decompressed using `method`. Assumes that `within_error_bound`
/// returns `false` if the number of uncompressed and decompressed values are different. The
/// libraries public interface is used to make it simpler to refactor the libraries internals.
pub fn testCompressAndDecompress(
    allocator: Allocator,
    uncompressed_values: []const f64,
    method: Method,
    error_bound: f32,
    withinErrorBound: fn (
        uncompressed_values: []const f64,
        decompressed_values: []const f64,
        error_bound: f32,
    ) bool,
) !void {
    const compressed_values = try tersets.compress(
        uncompressed_values,
        allocator,
        method,
        error_bound,
    );
    defer compressed_values.deinit();

    const decompressed_values = try tersets.decompress(compressed_values.items, allocator);
    defer decompressed_values.deinit();

    try testing.expect(withinErrorBound(
        uncompressed_values,
        decompressed_values.items,
        error_bound,
    ));
}

// Replace each normal value in `uncompressed_values` with a positive +inf, -inf, or NaN
// with the passed probability. The non-normal values are written to `uncompressed_values`
// in the previously listed order, thus a +inf maybe overwritten by a -inf
// and so on. The probabilities are asserted to be between zero and one.
pub fn replaceNormalValues(
    uncompressed_values: *ArrayList(f64),
    positive_infinity_probability: f32,
    negative_infinity_probability: f32,
    not_a_number_probability: f32,
    random: Random,
) void {
    debug.assert(0 <= positive_infinity_probability and positive_infinity_probability <= 1);
    debug.assert(0 <= negative_infinity_probability and negative_infinity_probability <= 1);
    debug.assert(0 <= not_a_number_probability and not_a_number_probability <= 1);

    for (0..uncompressed_values.items.len) |index| {
        if (random.float(f32) < positive_infinity_probability) {
            uncompressed_values.items[index] = math.inf(f64);
        }

        if (random.float(f32) < negative_infinity_probability) {
            uncompressed_values.items[index] = -math.inf(f64);
        }

        if (random.float(f32) < not_a_number_probability) {
            uncompressed_values.items[index] = math.nan(f64);
        }
    }
}

/// Generate a random `f64` value using `random_opt`. If `random_opt` is not passed, a random number
/// generator is created.
pub fn generateRandomValue(random_opt: ?Random) f64 {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = std.Random.DefaultPrng.init(seed);
    var random = random_opt orelse prng.random();

    // rand can only generate f64 values in the range [0, 1).
    const random_value = @as(f64, @bitCast(random.int(u64)));
    return random_value;
}

/// Generate a random number of `f64` values using `random` and add them to `uncompressed_values`.
/// The number of values is randomly chosen between 100 and 150. Each value is a random `f64`
/// generated from a random `u64` bit pattern, which may include special values such as NaN or inf.
pub fn generateRandomValues(uncompressed_values: *ArrayList(f64), random: Random) !void {
    for (0..generateNumberOfValues(random)) |_| {
        // Generate a random f64 by bit-casting a random u64.
        const random_value = @as(f64, @bitCast(random.int(u64)));
        try uncompressed_values.append(random_value);
    }
}

/// Generate a random number of `f64` values for use in testing using `random` and add
/// them to `uncompressed_values`. If the value is not finite, it is replaced with zero.
pub fn generateFiniteRandomValues(uncompressed_values: *ArrayList(f64), random: Random) !void {
    var index: usize = 0;
    while (index < generateNumberOfValues(random)) {
        // rand can only generate f64 values in the range [0, 1), thus using u64.
        const random_value = @as(f64, @bitCast(random.int(u64)));
        // Online add finite values.
        if (std.math.isFinite(random_value)) {
            try uncompressed_values.append(random_value);
            index += 1;
        }
    }
}

/// Generate a random number of `f64` values following a sinusoidal function
/// with random amplitude, frequency, and additive noise. The output values are
/// guaranteed to be finite and lie within the range [-1e15, 1e15]. The values
/// are generated using `random` and returned in `uncompressed_values`. If an
/// error occurs, it is returned.
pub fn generateRandomSinusoidalFunction(
    uncompressed_values: *ArrayList(f64),
    random: Random,
) !void {
    // Amplitude sampled in [1e-2, 1e14) allows very small to large oscillations.
    const amplitude = math.pow(f64, 10.0, random.float(f64) * 16.0 - 2.0);
    // Frequency sampled in [1e-4, 1e1) covers slowly to moderately fast variation.
    const frequency = math.pow(f64, 10.0, random.float(f64) * 5.0 - 4.0);
    // Phase sampled in [0, 2\pi) ensures random starting point in the cycle.
    const phase = random.float(f64) * 2.0 * math.pi;
    // Noise scale in [-5, 5) avoids pushing values beyond desired bounds.
    const noise_scale = random.float(f64) * 10 - 5;

    const n = generateNumberOfValues(random);
    try uncompressed_values.ensureUnusedCapacity(n);

    var i: usize = 0;
    while (i < n) : (i += 1) {
        const x = @as(f64, @floatFromInt(i));
        var value = amplitude * @sin(frequency * x + phase) + noise_scale;

        // Clamp to [-1e15, 1e15] to avoid overflows and invalid values.
        value = math.clamp(value, -max_test_value, max_test_value);
        uncompressed_values.appendAssumeCapacity(value);
    }
}

/// Generate a random number of linear functions with random slope and intercept using `random` and
/// add them to `uncompressed_values`.
pub fn generateRandomLinearFunctions(uncompressed_values: *ArrayList(f64), random: Random) !void {
    // Generate a random number of lines using `global_at_least` and `global_at_most`.
    const num_lines = random.intRangeAtMost(u32, global_at_least, global_at_most);
    for (0..num_lines) |_| {
        try generateRandomLinearFunction(uncompressed_values, random);
    }
}

/// Generate a random number of `f64` values for use in testing using `random` and add
/// them to `uncompressed_values`. The function also replaces some of the generated values with NaNs
/// and infinities with a almost probability one.
pub fn generateRandomValuesWithNaNs(values: *ArrayList(f64), random: Random) !void {
    try generateRandomValues(values, random);
    replaceNormalValues(
        values,
        global_replace_probability,
        global_replace_probability,
        global_replace_probability,
        random,
    );
}

/// Generate a random number of linear functions with random slope and intercept for use
/// in testing using `random` and add them to `uncompressed_values`. The function also replaces some
/// of the generated values with NaNs and infinities with almost probability one.
pub fn generateRandomLinearFunctionsWithNaNs(values: *ArrayList(f64), random: Random) !void {
    try generateRandomLinearFunctions(values, random);
    replaceNormalValues(
        values,
        global_replace_probability,
        global_replace_probability,
        global_replace_probability,
        random,
    );
}

/// Wrapper around `generateBoundedRandomValues` with a default range. The function generates
/// a random number of `f64` values between [-1e15, 1e15] for use in testing using
/// `random` and adds them to `uncompressed_values`. This range can be represented by a `f64`
/// without losing precision, thus it is used as a default range for testing purposes.
pub fn generateDefaultBoundedValues(values: *ArrayList(f64), random: Random) !void {
    try generateBoundedRandomValues(values, -1e15, 1e15, random);
}

/// Generate a random number of `f64` values values between -1e15 and 1e15 for use in testing using
/// `random` and add them to `uncompressed_values`. The function also replaces some of the
/// generated values with NaNs and infinities with almost probability one.
pub fn generateDefaultBoundedValuesWithNaNs(values: *ArrayList(f64), random: Random) !void {
    try generateDefaultBoundedValues(values, random);
    replaceNormalValues(
        values,
        global_replace_probability,
        global_replace_probability,
        global_replace_probability,
        random,
    );
}

/// Generate a random sinusoid (finite values) and then replace some of those values
/// with special values (NaN, +inf, -inf) using the given perâ€‘value probabilities inside
/// `replaceNormalValues`. The values are generated using `random` and return in `values`.
/// If an error is found, it is returned.
pub fn generateRandomSinusoidalFunctionWithNaNs(values: *ArrayList(f64), random: Random) !void {
    try generateRandomSinusoidalFunction(values, random);
    replaceNormalValues(
        values,
        global_replace_probability,
        global_replace_probability,
        global_replace_probability,
        random,
    );
}

/// Generate a random number of `f64` values between `lower_bound` and `upper_bound` for
/// use in testing using `random` and add them to `uncompressed_values`.
pub fn generateBoundedRandomValues(
    uncompressed_values: *ArrayList(f64),
    lower_bound: f64,
    upper_bound: f64,
    random_opt: ?Random,
) !void {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = std.Random.DefaultPrng.init(seed);
    var random = random_opt orelse prng.random();

    for (0..generateNumberOfValues(random)) |_| {
        // generate f64 values in the range [0, 1).
        const rand_value: f64 = random.float(f64);
        const bounded_value = lower_bound + (upper_bound - lower_bound) * rand_value;
        try uncompressed_values.append(bounded_value);
    }
}

/// Generate a random number of `f64` values following a linear function with random slope
/// and intercept, and add them to `uncompressed_values`. Small random noise is added to
/// each value. The generated values are bounded within [-1e15, 1e15]. If `random_opt` is
/// not passed, a random number generator is created.
pub fn generateRandomLinearFunction(uncompressed_values: *ArrayList(f64), random_opt: ?Random) !void {
    // If `random_opt` is not passed, a random number generator is created using the current time as seed.
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = std.Random.DefaultPrng.init(seed);
    var random = random_opt orelse prng.random();

    // Choose log-uniform magnitude in [1e-2, 1e12].
    const log_magnitude = random.float(f64) * 14.0 - 2.0;
    const magnitude = math.pow(f64, 10.0, log_magnitude);
    const sign: f64 = if (random.boolean()) 1.0 else -1.0;
    const slope = sign * magnitude;

    // Uniformly in [-1e10, 1e10]. This range is wide enough while avoiding f64 overflow.
    const intercept = 2.0e10 * random.float(f64) - 1e10;

    for (0..generateNumberOfValues(random)) |x| {
        // Small random noise in the range [-0.5, 0.5).
        const rand_value = random.float(f64) - 0.5;
        const linear_function_value = slope * @as(f64, @floatFromInt(x)) + intercept + rand_value;
        const clamped_value = math.clamp(linear_function_value, -1.0e15, 1.0e15);
        try uncompressed_values.append(clamped_value);
    }
}

/// Generate a random value of type `T` between `at_least` and `at_most` for use in testing using
/// `random_opt`. `T` must be a floating-point type (e.g., `f32`, `f64`). If random_opt is not
/// passed, a random number generator is created using the current time as seed.
pub fn generateBoundedRandomValue(comptime T: type, at_least: T, at_most: T, random_opt: ?Random) T {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = std.Random.DefaultPrng.init(seed);
    var random = random_opt orelse prng.random();

    const rand_value: T = random.float(T);
    const bounded_value = at_least + (at_most - at_least) * rand_value;
    return bounded_value;
}

/// Generate a random value of type `T` between `at_least` and `at_most` for use in testing using
/// `random_opt`. `T` must be an integer-point type (e.g., `i32`, `usize`). If random_opt is not
/// passed, a random number generator is created using the current time as seed.
pub fn generateBoundRandomInteger(comptime T: type, at_least: T, at_most: T, random_opt: ?Random) T {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = std.Random.DefaultPrng.init(seed);
    var random = random_opt orelse prng.random();

    const rand_value: T = random.intRangeAtMost(T, at_least, at_most);
    return rand_value;
}

/// Generate a random number of values used for testing. This value needs to be higher than or equal to 2
/// otherwise some of the tests will fail. The value is set to between [100-150] to ensure that the tests are
/// not too slow. The values is generated randomly to obtain a different set of values for each test run.
pub fn generateNumberOfValues(random: Random) usize {
    const number_of_values: usize = random.intRangeAtMost(usize, 100, 150);
    return number_of_values;
}
