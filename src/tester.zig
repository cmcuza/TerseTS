// Copyright 2024 TerseTS Contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Provides methods for testing TerseTS.

const std = @import("std");
const ArrayList = std.ArrayList;
const Random = std.Random;
const Allocator = std.mem.Allocator;
const Error = std.mem.Allocator.Error;
const math = std.math;
const time = std.time;
const testing = std.testing;
const debug = std.debug;

const tersets = @import("tersets.zig");
const Method = tersets.Method;

const shared = @import("utilities/shared_structs.zig");

/// Different data distributions used for testing.
pub const DataDistribution = enum {
    LinearFunctions,
    BoundedRandomValues,
    SinusoidalFunction,
    FiniteRandomValues,
    RandomValuesWithNansAndInfinities,
    LinearFunctionsWithNansAndInfinities,
    BoundedRandomValuesWithNansAndInfinities,
    SinusoidalFunctionWithNansAndInfinities,
};

/// Run a suite of experiments using different data generators to verify a compression `method`
/// works for a wide range of inputs. The `allocator` is used for memory management, and
/// `data_distributions` specifies which data distributions to test against the compression method.
pub fn testErrorBoundedCompressionMethod(
    allocator: Allocator,
    method: Method,
    data_distributions: []const DataDistribution,
) !void {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = Random.DefaultPrng.init(seed);
    const random = prng.random();

    for (data_distributions) |dist| {
        const error_bound: f32 = random.float(f32) + 0.0001; // Ensure a non-zero error bound.
        switch (dist) {
            .LinearFunctions => try testGeneratedCompression(
                allocator,
                generateRandomLinearFunctions,
                method,
                error_bound,
                "Linear Functions",
            ),
            .BoundedRandomValues => try testGeneratedCompression(
                allocator,
                generateDefaultBoundedValues,
                method,
                error_bound,
                "Bounded Values",
            ),
            .SinusoidalFunction => try testGeneratedCompression(
                allocator,
                generateRandomSinusoidalFunction,
                method,
                error_bound,
                "Sinusoidal Function",
            ),
            .FiniteRandomValues => try testGeneratedCompression(
                allocator,
                generateFiniteRandomValues,
                method,
                error_bound,
                "Finite Values",
            ),
            .RandomValuesWithNansAndInfinities => try testGeneratedCompression(
                allocator,
                generateRandomValuesWithNaNs,
                method,
                error_bound,
                "Random Values with NaNs and Infinities",
            ),
            .LinearFunctionsWithNansAndInfinities => try testGeneratedCompression(
                allocator,
                generateRandomLinearFunctionsWithNaNs,
                method,
                error_bound,
                "Linear Functions with NaNs and Infinities",
            ),
            .BoundedRandomValuesWithNansAndInfinities => try testGeneratedCompression(
                allocator,
                generateDefaultBoundedValuesWithNaNs,
                method,
                error_bound,
                "Bounded Random Values with NaNs and Infinities",
            ),
            .SinusoidalFunctionWithNansAndInfinities => try testGeneratedCompression(
                allocator,
                generateRandomSinusoidalFunctionWithNaNs,
                method,
                error_bound,
                "Sinusoidal Function with NaNs and Infinities",
            ),
        }
    }
}

/// Test that values generated by `uncompressedValuesGenerator` are within `error_bound` after they
/// have been compressed and decompressed using `method`. The libraries public interface is used to
/// make it simpler refactor the libraries internals.
pub fn testGeneratedCompression(
    allocator: Allocator,
    uncompressedValuesGenerator: fn (
        uncompressed_values: *ArrayList(f64),
        random: Random,
    ) Error!void,
    method: Method,
    error_bound: f32,
    data_distribution_name: []const u8,
) !void {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = Random.DefaultPrng.init(seed);
    const random = prng.random();

    var uncompressed_values = ArrayList(f64).init(allocator);
    defer uncompressed_values.deinit();
    try uncompressedValuesGenerator(&uncompressed_values, random);

    // Ensure that the error bound is a percentage of the range of the uncompressed values.
    // To avoid scanning for the minimum and maximum values, the first and last values are used
    // as a proxy for the range. This is a simplification, but it is sufficient for testing purposes.
    // Adding 0.0001 to avoid a zero error bound in case the first and last values are equal.
    const ranged_error_bound: f32 = @floatCast(@abs(
        uncompressed_values.items[0] - uncompressed_values.items[uncompressed_values.items.len - 1],
    ) * error_bound + 0.0001);

    const compressed = try tersets.compress(
        uncompressed_values.items,
        allocator,
        method,
        ranged_error_bound,
    );
    defer compressed.deinit();

    const decompressed = try tersets.decompress(compressed.items, allocator);
    defer decompressed.deinit();

    if (uncompressed_values.items.len != decompressed.items.len) {
        try testing.expectFmt(
            "",
            "Seed: {}, expected_len {}, found_len {}",
            .{ seed, uncompressed_values.items.len, decompressed.items.len },
        );
        return;
    }

    for (uncompressed_values.items, decompressed.items, 0..) |raw_value, decompressed_value, i| {
        // Check if the decompressed value is within the error bound of the expected value.
        // Cast the difference between raw and decompressed values to f32 before comparing
        // to the f32 error bound, to ignore insignificant differences below f32 precision.
        // This prevents false test failures due to f64 rounding noise.
        if (@as(f32, @floatCast(@abs(raw_value - decompressed_value))) > ranged_error_bound) {
            try testing.expectFmt(
                "",
                "Seed: {}, index {}, raw value {}, compressed value {}, error bound {},\n error bound exceeded by {}, with data distribution: {s} \n previous raw value {}, next raw value {}\n",
                .{
                    seed,
                    i,
                    raw_value,
                    decompressed_value,
                    ranged_error_bound,
                    @abs(raw_value - decompressed_value) - ranged_error_bound,
                    data_distribution_name,
                    if (i - 1 >= 0) uncompressed_values.items[i - 1] else 0.0,
                    if (i + 1 < uncompressed_values.items.len) uncompressed_values.items[i + 1] else 0.0,
                },
            );
            return;
        }
    }
}

/// Test that values generated by `uncompressed_values_generator` are within `error_bound` according
/// to `within_error_bound` after they have been compressed and decompressed using `method`. The
/// libraries public interface is used to make it simpler refactor the libraries internals.
pub fn testGenerateCompressAndDecompress(
    allocator: Allocator,
    uncompressedValuesGenerator: fn (
        uncompressed_values: *ArrayList(f64),
        random: Random,
    ) Error!void,
    method: Method,
    error_bound: f32,
    withinErrorBound: fn (
        uncompressed_values: []const f64,
        decompressed_values: []const f64,
        error_bound: f32,
    ) bool,
) !void {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = Random.DefaultPrng.init(seed);
    const random = prng.random();

    var uncompressed_values = ArrayList(f64).init(allocator);
    try uncompressedValuesGenerator(&uncompressed_values, random);
    defer uncompressed_values.deinit();

    // subsequenceStack contains subsequences to run the test for to find shortest failing sequence.
    var subsequenceStack = ArrayList(usize).init(allocator);
    defer subsequenceStack.deinit();

    try subsequenceStack.append(0);
    try subsequenceStack.append(uncompressed_values.items.len);
    var shortestStart: usize = 0;
    var shortestEnd: usize = math.maxInt(usize);

    while (subsequenceStack.items.len != 0) {
        // subsequenceStack contains start and end as separate integers of usize.
        const end = subsequenceStack.pop().?;
        const start = subsequenceStack.pop().?;
        const uncompressed_values_subsequence = uncompressed_values.items[start..end];

        testCompressAndDecompress(
            allocator,
            uncompressed_values_subsequence,
            method,
            error_bound,
            withinErrorBound,
        ) catch {
            // To simplify debugging failed tests that use auto generated data, the tests are
            // retried with smaller subsequence to find the smallest subsequence that fails.
            if (start < end - 1) {
                const middle = (start + end) / 2;
                try subsequenceStack.append(start);
                try subsequenceStack.append(middle);
                try subsequenceStack.append(middle);
                try subsequenceStack.append(end);
            }

            if (end - start < shortestEnd - shortestStart) {
                shortestStart = start;
                shortestEnd = end;
            }

            // Subsequences cannot be shorter than one element.
            if (end - start == 1) {
                break;
            }
        };
    }

    // HACK: std.testing has no functionality including a message with an error, thus a string with
    // an informative message is compared to an empty string to ensure it will fail and be printed.
    if (shortestEnd != math.maxInt(usize)) {
        try testing.expectFmt(
            "",
            "Seed: {}, Values: {any}",
            .{ seed, uncompressed_values.items[shortestStart..shortestEnd] },
        );
    }
}

/// Test that `uncompressed_values` are within `error_bound` according to `within_error_bound` after
/// it has been compressed and decompressed using `method`. Assumes that `within_error_bound`
/// returns `false` if the number of uncompressed and decompressed values are different. The
/// libraries public interface is used to make it simpler to refactor the libraries internals.
pub fn testCompressAndDecompress(
    allocator: Allocator,
    uncompressed_values: []const f64,
    method: Method,
    error_bound: f32,
    withinErrorBound: fn (
        uncompressed_values: []const f64,
        decompressed_values: []const f64,
        error_bound: f32,
    ) bool,
) !void {
    const compressed_values = try tersets.compress(
        uncompressed_values,
        allocator,
        method,
        error_bound,
    );
    defer compressed_values.deinit();

    const decompressed_values = try tersets.decompress(compressed_values.items, allocator);
    defer decompressed_values.deinit();

    try testing.expect(withinErrorBound(
        uncompressed_values,
        decompressed_values.items,
        error_bound,
    ));
}

// Replace each normal value in `uncompressed_values` with a positive infinity, negative infinity,
// or NaN with the passed probability. The non-normal values are written to `uncompressed_values`
// in the previously listed order, thus a positive infinity maybe overwritten by a negative infinity
// and so on. The probabilities are asserted to be between zero and one.
pub fn replaceNormalValues(
    uncompressed_values: *ArrayList(f64),
    positive_infinity_probability: f32,
    negative_infinity_probability: f32,
    not_a_number_probability: f32,
    random: Random,
) void {
    debug.assert(0 <= positive_infinity_probability and positive_infinity_probability <= 1);
    debug.assert(0 <= negative_infinity_probability and negative_infinity_probability <= 1);
    debug.assert(0 <= not_a_number_probability and not_a_number_probability <= 1);

    for (0..uncompressed_values.items.len) |index| {
        if (random.float(f32) < positive_infinity_probability) {
            uncompressed_values.items[index] = math.inf(f64);
        }

        if (random.float(f32) < negative_infinity_probability) {
            uncompressed_values.items[index] = -math.inf(f64);
        }

        if (random.float(f32) < not_a_number_probability) {
            uncompressed_values.items[index] = math.nan(f64);
        }
    }
}

/// Generate a random number of `f64` values for use in testing using `random` and add
/// them to `uncompressed_values`. The number of values is generated randomly between 100 and 150.
pub fn generateRandomValues(uncompressed_values: *ArrayList(f64), random: Random) !void {
    for (0..generateNumberOfValues(random)) |_| {
        // rand can only generate f64 values in the range [0, 1).
        const random_value = @as(f64, @bitCast(random.int(u64)));
        try uncompressed_values.append(random_value);
    }
}

/// Generate a random number of `f64` values for use in testing using `random` and add
/// them to `uncompressed_values`. If the value is not finite, it is replaced with zero.
pub fn generateFiniteRandomValues(uncompressed_values: *ArrayList(f64), random: Random) !void {
    var index: usize = 0;
    while (index < generateNumberOfValues(random)) {
        // rand can only generate f64 values in the range [0, 1), thus using u64.
        const random_value = @as(f64, @bitCast(random.int(u64)));
        // Online add finite values.
        if (std.math.isFinite(random_value)) {
            try uncompressed_values.append(random_value);
            index += 1;
        }
    }
}

/// Generate a random number of `f64` values following a sinusoidal function with random
/// amplitude and frequency using `random`. Random noise is added to each generated value and add
/// to `uncompressed_values`.
pub fn generateRandomSinusoidalFunction(uncompressed_values: *ArrayList(f64), random: Random) !void {
    const amplitude = 1.0 + 5.0 * random.float(f64); // [1,6)
    const frequency = 0.1 + random.float(f64); // [0.1,1.1)
    const phase = random.float(f64) * 2.0 * math.pi;

    for (0..generateNumberOfValues(random)) |x| {
        const noise = random.float(f64) - 0.5;
        const value = amplitude * @sin(frequency * @as(f64, @floatFromInt(x)) + phase) + noise;
        try uncompressed_values.append(value);
    }
}

/// Generate a random number of linear functions with random slope and intercept using `random` and
/// add them to `uncompressed_values`.
pub fn generateRandomLinearFunctions(uncompressed_values: *ArrayList(f64), random: Random) !void {
    // Generate a random number of lines between 10 and 20
    const num_lines = 10 + random.intRangeAtMost(u32, 0, 10);
    for (0..num_lines) |_| {
        try generateRandomLinearFunction(uncompressed_values, random);
    }
}

/// Generate a random number of `f64` values for use in testing using `random` and add
/// them to `uncompressed_values`. The function also replaces some of the generated values with NaNs
/// and infinities with a almost probability one.
pub fn generateRandomValuesWithNaNs(values: *ArrayList(f64), random: Random) !void {
    try generateRandomValues(values, random);
    // Since the function `generateRandomLinearFunctions` generates 100 values, the probability of
    // replacing a value with NaN or infinity is 0.05, thus the expected number of NaNs and
    // infinities is 5. Then, the probability of having at least one NaN or infinity is
    // 1 - (1 - 0.05) ^ 3 ^ 100, which is approximately 0.9999, thus almost one.
    replaceNormalValues(values, 0.05, 0.05, 0.05, random);
}

/// Generate a random number of linear functions with random slope and intercept for use
/// in testing using `random` and add them to `uncompressed_values`. The function also replaces some
/// of the generated values with NaNs and infinities with almost probability one.
pub fn generateRandomLinearFunctionsWithNaNs(values: *ArrayList(f64), random: Random) !void {
    try generateRandomLinearFunctions(values, random);
    // Since the function `generateRandomLinearFunctions` generates 100 values, the probability of
    // replacing a value with NaN or infinity is 0.05, thus the expected number of NaNs and
    // infinities is 5. Then, the probability of having at least one NaN or infinity is
    // 1 - (1 - 0.05) ^ 3 ^ 100, which is approximately 0.9999, thus almost one.
    replaceNormalValues(values, 0.05, 0.05, 0.05, random);
}

/// Wrapper around `generateBoundedRandomValues` with a default range. The function generates
/// a random number of `f64` values between [-1e14, 1e14] for use in testing using
/// `random` and adds them to `uncompressed_values`. This range can be represented by a `f64`
/// without losing precision, thus it is used as a default range for testing purposes.
pub fn generateDefaultBoundedValues(values: *ArrayList(f64), random: Random) !void {
    try generateBoundedRandomValues(values, -1e14, 1e14, random);
}

/// Generate a random number of `f64` values values between -1e14 and 1e14 for use in testing using
/// `random` and add them to `uncompressed_values`. The function also replaces some of the
/// generated values with NaNs and infinities with almost probability one.
pub fn generateDefaultBoundedValuesWithNaNs(values: *ArrayList(f64), random: Random) !void {
    try generateDefaultBoundedValues(values, random);
    // Since the function `generateDefaultBoundedValues` generates 100 values, the probability of
    // replacing a value with NaN or infinity is 0.05, thus the expected number of NaNs and
    // infinities is 5. Then, the probability of having at least one NaN or infinity is
    // 1 - (1 - 0.05) ^ 3 ^ 100, which is approximately 0.9999, thus almost one.
    replaceNormalValues(values, 0.05, 0.05, 0.05, random);
}

/// Generate a random number of linear functions with random slope and intercept for use
/// in testing using `random` and add them to `uncompressed_values`. The function also replaces some
/// of the generated values with NaNs and infinities with almost probability one.
pub fn generateRandomSinusoidalFunctionWithNaNs(values: *ArrayList(f64), random: Random) !void {
    try generateRandomSinusoidalFunction(values, random);
    // Since the function `generateRandomSinusoidalFunction` generates 100 values, the probability of
    // replacing a value with NaN or infinity is 0.05, thus the expected number of NaNs and
    // infinities is 5. Then, the probability of having at least one NaN or infinity is
    // 1 - (1 - 0.05) ^ 3 ^ 100, which is approximately 0.9999, thus almost one.
    replaceNormalValues(values, 0.05, 0.05, 0.05, random);
}

/// Generate a random number of `f64` values between `lower_bound` and `upper_bound` for
/// use in testing using `random` and add them to `uncompressed_values`.
pub fn generateBoundedRandomValues(
    uncompressed_values: *ArrayList(f64),
    lower_bound: f64,
    upper_bound: f64,
    random_opt: ?Random,
) !void {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = std.Random.DefaultPrng.init(seed);
    var random = random_opt orelse prng.random();

    for (0..generateNumberOfValues(random)) |_| {
        // generate f64 values in the range [0, 1).
        const rand_value: f64 = random.float(f64);
        const bounded_value = lower_bound + (upper_bound - lower_bound) * rand_value;
        try uncompressed_values.append(bounded_value);
    }
}

/// Generate a random number of `f64` values following a linear function of random slope
/// and intercept for use in testing using `random_opt`. Random noise is add to the elements and then
/// add to `uncompressed_values`.If `random_opt` is not passed, a random number generator is created.
pub fn generateRandomLinearFunction(uncompressed_values: *ArrayList(f64), random_opt: ?Random) !void {
    // If `random_opt` is not passed, a random number generator is created using the current time as seed.
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = std.Random.DefaultPrng.init(seed);
    var random = random_opt orelse prng.random();

    // Generate a random slope in the range [-10, 10]. Multiply by 1000 to increase changes of getting
    // a value different from zero.
    var rand_value: f64 = random.float(f64);
    const slope: f64 = @round((rand_value - 0.5) * 1000) / 100;

    // Repeat the process before to generate a random intercept in the range [-10, 10].
    rand_value = random.float(f64);
    const intercept: f64 = @round((rand_value - 0.5) * 1000) / 100;

    for (0..generateNumberOfValues(random)) |x| {
        rand_value = random.float(f64) - 0.5; // Random noise in the range [-0.5, 0.5).
        const linear_function_value = slope * @as(f64, @floatFromInt(x)) + intercept + rand_value;
        try uncompressed_values.append(linear_function_value);
    }
}

/// Generate a random value of type `T` between `lower_bound` and `upper_bound` for use in testing using `random`.
/// `T` must be a floating-point type (e.g., `f32`, `f64`).
pub fn generateBoundedRandomValue(comptime T: type, lower_bound: T, upper_bound: T, random_opt: ?Random) T {
    const seed: u64 = @bitCast(time.milliTimestamp());
    var prng = std.Random.DefaultPrng.init(seed);
    var random = random_opt orelse prng.random();

    const rand_value: T = random.float(T);
    const bounded_value = lower_bound + (upper_bound - lower_bound) * rand_value;
    return bounded_value;
}

/// Generate a random number of values used for testing. This value needs to be higher than or equal to 2
/// otherwise some of the tests will fail. The value is set to between [100-150] to ensure that the tests are
/// not too slow. The values is generated randomly to obtain a different set of values for each test run.
pub fn generateNumberOfValues(random: Random) usize {
    const number_of_values: usize = 100 + random.intRangeAtMost(u32, 0, 50);
    return number_of_values;
}
